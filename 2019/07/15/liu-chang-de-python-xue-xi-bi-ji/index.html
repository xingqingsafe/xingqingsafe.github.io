<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="流畅的Python学习笔记"><meta name="keywords" content><meta name="author" content="starjian"><meta name="copyright" content="starjian"><title>流畅的Python学习笔记 | 星晴</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#流畅的python学习笔记"><span class="toc-number">1.</span> <span class="toc-text">流畅的python学习笔记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第一章节-python特殊方法"><span class="toc-number">2.</span> <span class="toc-text">第一章节 python特殊方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二章节-序列"><span class="toc-number">3.</span> <span class="toc-text">第二章节  序列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-1-列表的分类"><span class="toc-number">4.</span> <span class="toc-text">2.1 列表的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-列表的推导和可读性（生成列表）"><span class="toc-number">4.1.</span> <span class="toc-text">2.2 列表的推导和可读性（生成列表）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-生成器表达式"><span class="toc-number">4.2.</span> <span class="toc-text">2.3 生成器表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-元组"><span class="toc-number">4.3.</span> <span class="toc-text">2.4 元组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-切片"><span class="toc-number">4.4.</span> <span class="toc-text">2.5 切片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-为什么切片最后一个值不取？"><span class="toc-number">4.4.1.</span> <span class="toc-text">2.5.1 为什么切片最后一个值不取？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-切片的间隔取值"><span class="toc-number">4.4.2.</span> <span class="toc-text">2.5.2 切片的间隔取值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-多维切片和省略"><span class="toc-number">4.4.3.</span> <span class="toc-text">2.5.3 多维切片和省略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-4-序列使用-和"><span class="toc-number">4.4.4.</span> <span class="toc-text">2.5.4 序列使用+和*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-5-序列的增量赋值"><span class="toc-number">4.4.5.</span> <span class="toc-text">2.5.5 序列的增量赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-6-list-sort和sorted的区别"><span class="toc-number">4.4.6.</span> <span class="toc-text">2.5.6 list.sort和sorted的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-7-bisect和insort进行已排序的序列的管理"><span class="toc-number">4.4.7.</span> <span class="toc-text">2.5.7  bisect和insort进行已排序的序列的管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-9-deque"><span class="toc-number">4.4.8.</span> <span class="toc-text">2.5.9 deque</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三章-字典和集合"><span class="toc-number">5.</span> <span class="toc-text">第三章 字典和集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-常见的映射方法"><span class="toc-number">5.1.</span> <span class="toc-text">1.常见的映射方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-使用setdefault处理找不到的键"><span class="toc-number">5.2.</span> <span class="toc-text">2.使用setdefault处理找不到的键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-映射的弹性键查询"><span class="toc-number">5.3.</span> <span class="toc-text">3.映射的弹性键查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-字典的变种"><span class="toc-number">5.4.</span> <span class="toc-text">4.字典的变种</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-集合"><span class="toc-number">5.5.</span> <span class="toc-text">5.集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-字典中的散列表"><span class="toc-number">5.6.</span> <span class="toc-text">6.字典中的散列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-字典的实现及其导致的结果"><span class="toc-number">5.7.</span> <span class="toc-text">7.字典的实现及其导致的结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-集合的实现以及导致的结果"><span class="toc-number">5.8.</span> <span class="toc-text">8.集合的实现以及导致的结果</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第四章-文本和字节序列"><span class="toc-number">6.</span> <span class="toc-text">第四章 文本和字节序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-字符问题"><span class="toc-number">6.1.</span> <span class="toc-text">1.字符问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-字节概要"><span class="toc-number">6.2.</span> <span class="toc-text">2.字节概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-编程中的编码问题"><span class="toc-number">6.3.</span> <span class="toc-text">3.编程中的编码问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-编码为字节的问题"><span class="toc-number">6.3.1.</span> <span class="toc-text">3.1 编码为字节的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-解码中的问题"><span class="toc-number">6.3.2.</span> <span class="toc-text">3.2 解码中的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-使用预期之外的编码加载模块时抛出的syntaxerror"><span class="toc-number">6.3.3.</span> <span class="toc-text">3.3 使用预期之外的编码加载模块时抛出的syntaxerror</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4如何找出字节序列的编码"><span class="toc-number">6.3.4.</span> <span class="toc-text">3.4如何找出字节序列的编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-python处理文本文件"><span class="toc-number">6.3.5.</span> <span class="toc-text">3.5 python处理文本文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第五章-一等对象函数"><span class="toc-number">6.4.</span> <span class="toc-text">第五章 一等对象函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-高阶函数"><span class="toc-number">6.4.1.</span> <span class="toc-text">1 高阶函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-匿名函数"><span class="toc-number">6.4.2.</span> <span class="toc-text">2.匿名函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-可调用对象"><span class="toc-number">6.4.3.</span> <span class="toc-text">3.可调用对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-用户自定义的可调用类型"><span class="toc-number">6.4.4.</span> <span class="toc-text">4.用户自定义的可调用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-函数内省"><span class="toc-number">6.4.5.</span> <span class="toc-text">5.函数内省</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">starjian</div><div class="author-info__description text-center">白帽子星晴的成长记录博客</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">36</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">星晴</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">流畅的Python学习笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-15</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="流畅的python学习笔记"><a href="#流畅的python学习笔记" class="headerlink" title="流畅的python学习笔记"></a>流畅的python学习笔记</h1><hr>
<h1 id="第一章节-python特殊方法"><a href="#第一章节-python特殊方法" class="headerlink" title="第一章节 python特殊方法"></a>第一章节 python特殊方法</h1><ol>
<li><p>python里面的特殊方法(魔术方法)  <code>__getitem__</code>,<code>len（）</code></p>
</li>
<li><p>collections.namedtuple构建一个简单的类，这个类只有少量的属性没有方法</p>
<p><code>def namedtuple(typename, field_names, verbose=False, rename=False)</code></p>
<p><strong>typename:</strong>类名称</p>
<p><strong>field_names：</strong>字段名称，保证元素间顺序不变的可遍历对象或者是逗号链接起来的字符串</p>
<p><strong>verbose</strong>：设置为true的话会打印出类的定义代码</p>
</li>
<li><p>for i in x: 实际上调用的是iter(x)，<code>x.__iter__()</code>方法</p>
</li>
<li><p><code>__repr_</code>将对象用字符串的形式表达出来，交互式控制台和调试程序用repr函数来获取字符串表示</p>
</li>
<li><p><code>__repr__</code>和<code>__str__</code>的区别:str函数或者print打印一个对象的时候调用，如果没用实现str函数，python会使用repr调用，repr式用来记录日志，后者式用来给终端用户看的</p>
</li>
<li><p>if (一个对象)或者while(一个对象)会调用这个对象的bool魔术方法，如果这个魔术方法没用定义它会len方法，返回0就是false,否则就会返回true</p>
</li>
<li><p>len的方法在内置类中调用特别块，因为它使用了cpython直接从C结构体中读取对象的长度，完全不会调用任何方法，</p>
</li>
</ol>
<h1 id="第二章节-序列"><a href="#第二章节-序列" class="headerlink" title="第二章节  序列"></a>第二章节  序列</h1><h1 id="2-1-列表的分类"><a href="#2-1-列表的分类" class="headerlink" title="2.1 列表的分类"></a>2.1 列表的分类</h1><p>序列分为两种：</p>
<p>容器序列：list、tuple、collections.deque可以存放不同类型的数据，存放的是对象的引用</p>
<p>扁平序列:</p>
<p>str、bytes、bytearray、memoryview和array.array都只能容纳一种类型，存放的不是引用，是值。</p>
<p>可变的序列: list、bytearray、array.array、collections.deque和memoryview</p>
<p>不可变的：tuple、str和bytes。</p>
<h2 id="2-2-列表的推导和可读性（生成列表）"><a href="#2-2-列表的推导和可读性（生成列表）" class="headerlink" title="2.2 列表的推导和可读性（生成列表）"></a>2.2 列表的推导和可读性（生成列表）</h2><h2 id="2-3-生成器表达式"><a href="#2-3-生成器表达式" class="headerlink" title="2.3 生成器表达式"></a>2.3 生成器表达式</h2><p>生成器表达式可以逐个的产出元素，而不是建立一个完整的列表，方括号换成圆括号。</p>
<h2 id="2-4-元组"><a href="#2-4-元组" class="headerlink" title="2.4 元组"></a>2.4 元组</h2><p>不可变的列表+<strong>记录</strong></p>
<p>b,a=a,b交换变量</p>
<p>divmod（20，8）=（2，4）</p>
<p>元组的拆包</p>
<p>具名元组：collections.namedtuple的使用</p>
<h2 id="2-5-切片"><a href="#2-5-切片" class="headerlink" title="2.5 切片"></a>2.5 切片</h2><h3 id="2-5-1-为什么切片最后一个值不取？"><a href="#2-5-1-为什么切片最后一个值不取？" class="headerlink" title="2.5.1 为什么切片最后一个值不取？"></a>2.5.1 为什么切片最后一个值不取？</h3><p>元组列表和字符串都支持切片操作。python的切片和区间操作不包含区间范围的最后一个元素是python的风格，</p>
<p>切片忽略最后一个元素的好处：</p>
<ul>
<li>当只有末尾的数字的index的时候可以快速看出切片和区间里含有几个元素</li>
<li>当起止位置信息都可见的时候，可以快速计算出切片和区间的长度，</li>
<li>快速将序列分割成不重叠的两部分，my_list[:x]和my_list[x:]可以</li>
</ul>
<h3 id="2-5-2-切片的间隔取值"><a href="#2-5-2-切片的间隔取值" class="headerlink" title="2.5.2 切片的间隔取值"></a>2.5.2 切片的间隔取值</h3><p>s[a,b,c]<code>其中c为负值就是反向取值</code>seq.<strong>getitem</strong>(slice(start,stop,step))`</p>
<p>slice对象</p>
<h3 id="2-5-3-多维切片和省略"><a href="#2-5-3-多维切片和省略" class="headerlink" title="2.5.3 多维切片和省略"></a>2.5.3 多维切片和省略</h3><h3 id="2-5-4-序列使用-和"><a href="#2-5-4-序列使用-和" class="headerlink" title="2.5.4 序列使用+和*"></a>2.5.4 序列使用+和*</h3><p>不会修改原来的操作对象，构建一个全新的序列。</p>
<h3 id="2-5-5-序列的增量赋值"><a href="#2-5-5-序列的增量赋值" class="headerlink" title="2.5.5 序列的增量赋值"></a>2.5.5 序列的增量赋值</h3><p>+=<code>使用的特殊方法是&#39;__iadd__</code>，如果没实现就会调用<code>__add__</code></p>
<p>不可变使用就会重新创建。可变数组会改变数组的值</p>
<p><strong>These Python Tutor</strong> ，很好可视化代码的工具</p>
<p>dis.dis查看字节码，可以看到代码背后的运行机制。</p>
<h3 id="2-5-6-list-sort和sorted的区别"><a href="#2-5-6-list-sort和sorted的区别" class="headerlink" title="2.5.6 list.sort和sorted的区别"></a>2.5.6 list.sort和sorted的区别</h3><p>sort不会返回值，它直接会就地进行一个排序，函数存在两个参数 key和reverse</p>
<h3 id="2-5-7-bisect和insort进行已排序的序列的管理"><a href="#2-5-7-bisect和insort进行已排序的序列的管理" class="headerlink" title="2.5.7  bisect和insort进行已排序的序列的管理"></a>2.5.7  bisect和insort进行已排序的序列的管理</h3><h3 id="2-5-9-deque"><a href="#2-5-9-deque" class="headerlink" title="2.5.9 deque"></a>2.5.9 deque</h3><h1 id="第三章-字典和集合"><a href="#第三章-字典和集合" class="headerlink" title="第三章 字典和集合"></a>第三章 字典和集合</h1><p>isinstance(my_dict,abc.Mapping),可散列需要有两个方法:<code>__hash_`</code>和<strong>qe</strong>`,</p>
<p>字典推导</p>
<h2 id="1-常见的映射方法"><a href="#1-常见的映射方法" class="headerlink" title="1.常见的映射方法"></a>1.常见的映射方法</h2><p>dict、collections.defaultdict、defaultdict.orderedDict</p>
<h2 id="2-使用setdefault处理找不到的键"><a href="#2-使用setdefault处理找不到的键" class="headerlink" title="2.使用setdefault处理找不到的键"></a>2.使用setdefault处理找不到的键</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict.setdefault(key, default=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>setdefault 同时也会改变 dict 的值</p>
<h2 id="3-映射的弹性键查询"><a href="#3-映射的弹性键查询" class="headerlink" title="3.映射的弹性键查询"></a>3.映射的弹性键查询</h2><h2 id="4-字典的变种"><a href="#4-字典的变种" class="headerlink" title="4.字典的变种"></a>4.字典的变种</h2><p>collections.OrdereDict</p>
<p>子类化UserDict</p>
<h2 id="5-集合"><a href="#5-集合" class="headerlink" title="5.集合"></a>5.集合</h2><p>集合推导</p>
<h2 id="6-字典中的散列表"><a href="#6-字典中的散列表" class="headerlink" title="6.字典中的散列表"></a>6.字典中的散列表</h2><p> 散列表是一个稀疏数组，大概三分之一的空间是空的</p>
<p>内置的hash用于所有的内置类型的对象，且如果两个对象在比较的时候是相等的，那它们的散列值必须是相等的，否则散列表就不能正常的运行。如1==1.0返回true，那么hash(1)==hash(1.0)必须为真。</p>
<p>散列表算法：</p>
<p>获取my_dict[search_key]背后值，python首先会调用hash(search_key)来计算search_key的散列值，</p>
<p><img src="/.com//Typora/流畅的Python学习笔记/1563271134377.png" alt="1563271134377"></p>
<h2 id="7-字典的实现及其导致的结果"><a href="#7-字典的实现及其导致的结果" class="headerlink" title="7.字典的实现及其导致的结果"></a>7.字典的实现及其导致的结果</h2><p>键必须是可散列的，可散列指的是:</p>
<ol>
<li>支持hash()函数，通过 <code>__hash_()</code>方法所得到的散列值是不变的</li>
<li>支持<code>__eq__（）</code>方法检测相等性</li>
<li>若a==b为真，则hash(a)==hash(b)也为真。</li>
</ol>
<p>字典的劣势:</p>
<p>字典在内存上的开销比较大，可以用具名元祖来代替字典。<code>__slots_</code>可以改变实例属性的存储方式，由dict变成tuple.</p>
<p>键的次序取决于添加顺序</p>
<p>字典添加新建可能改变已有键的顺序</p>
<h2 id="8-集合的实现以及导致的结果"><a href="#8-集合的实现以及导致的结果" class="headerlink" title="8.集合的实现以及导致的结果"></a>8.集合的实现以及导致的结果</h2><p>散列表存放的是元素的引用。</p>
<p>集合里面的元素必须是可散列的，集合很消耗内存，可以很高效的判断元素是否是存在于集合</p>
<p>元素的次序取决于被添加到集合里的次序</p>
<p>往集合里面添加元素，可能会改变集合里已有元素的次序</p>
<h1 id="第四章-文本和字节序列"><a href="#第四章-文本和字节序列" class="headerlink" title="第四章 文本和字节序列"></a>第四章 文本和字节序列</h1><h2 id="1-字符问题"><a href="#1-字符问题" class="headerlink" title="1.字符问题"></a>1.字符问题</h2><p><strong>编码</strong>: 字符串的unicode 码位变成用于存储以及传输的字节形式</p>
<p><strong>解码</strong>：就是将字节转化位人类可以看到的字符串。</p>
<h2 id="2-字节概要"><a href="#2-字节概要" class="headerlink" title="2.字节概要"></a>2.字节概要</h2><p>bytes和bytearray的切片仍然是一个切片，元素是一个十进制的数，str[0]==str[:1]，但是bytes[:1]!=bytes[0].</p>
<h2 id="3-编程中的编码问题"><a href="#3-编程中的编码问题" class="headerlink" title="3.编程中的编码问题"></a>3.编程中的编码问题</h2><h3 id="3-1-编码为字节的问题"><a href="#3-1-编码为字节的问题" class="headerlink" title="3.1 编码为字节的问题"></a>3.1 编码为字节的问题</h3><p>encode中使用errors参数，指定位ignore将忽略这个不能编码的错误</p>
<p>使用replace将会用?来代替不能编码的字符</p>
<p>使用xmlcharrefreplace将会用xml实体来代替不可编码的字符</p>
<h3 id="3-2-解码中的问题"><a href="#3-2-解码中的问题" class="headerlink" title="3.2 解码中的问题"></a>3.2 解码中的问题</h3><p><code>octets.decode(&#39;utf_8&#39;, errors=&#39;replace&#39;)</code> </p>
<h3 id="3-3-使用预期之外的编码加载模块时抛出的syntaxerror"><a href="#3-3-使用预期之外的编码加载模块时抛出的syntaxerror" class="headerlink" title="3.3 使用预期之外的编码加载模块时抛出的syntaxerror"></a>3.3 使用预期之外的编码加载模块时抛出的syntaxerror</h3><p><code># coding: cp1252</code></p>
<h3 id="3-4如何找出字节序列的编码"><a href="#3-4如何找出字节序列的编码" class="headerlink" title="3.4如何找出字节序列的编码"></a>3.4如何找出字节序列的编码</h3><p>假如有个文本文件，里面保存的是源码或诗句，但是你不知道它的编码。如何查明真正的编码呢？</p>
<p>统一字符编码侦测包Chardet（<a href="https://pypi.python.org/pypi/chardet）就是这样工作的，它能识别所支持的30" target="_blank" rel="noopener">https://pypi.python.org/pypi/chardet）就是这样工作的，它能识别所支持的30</a> 种编码。Chardet 是一个Python 库，<br>可以在程序中使用，不过它也提供了命令行工具chardetect。下面是它对本章书稿文件的检测报告：</p>
<h3 id="3-5-python处理文本文件"><a href="#3-5-python处理文本文件" class="headerlink" title="3.5 python处理文本文件"></a>3.5 python处理文本文件</h3><p>python中的默认文本编码：</p>
<ol>
<li>文本文件默认使用locale.getpreferredencoding()，如果打开文件时没有指定encoding 参数，默认值由<br>locale.getpreferredencoding() 提供。</li>
<li>如果设定了PYTHONIOENCODING 环境变量（<a href="https://docs.python.org/3/using/cmdline.html#envvarPYTHONIOENCODING），sys.stdout/stdin/stderr" target="_blank" rel="noopener">https://docs.python.org/3/using/cmdline.html#envvarPYTHONIOENCODING），sys.stdout/stdin/stderr</a> 的编码使用设定的值；否则，继承自所在的控制台；如果输入/ 输出重定向到文件，则由locale.getpreferredencoding() 定义</li>
<li>Python 在二进制数据和字符串之间转换时，内部使用sys.getdefaultencoding() 获得的编码；</li>
<li>sys.getfilesystemencoding() 用于编解码文件名</li>
<li>locale.getpreferredencoding() 返回的编码是最重要的：这是打开文件的默认编码，也是重定向到文件的sys.stdout/stdin/stderr 的默认编码</li>
</ol>
<h2 id="第五章-一等对象函数"><a href="#第五章-一等对象函数" class="headerlink" title="第五章 一等对象函数"></a>第五章 一等对象函数</h2><p>在python中，函数是一等对象。一等对象具有以下的特性：</p>
<ul>
<li>在运行时创建</li>
<li>能赋值给变量或数据结构中的元素</li>
<li>能作为参数传给函数</li>
<li>能作为函数的返回结果</li>
</ul>
<h3 id="1-高阶函数"><a href="#1-高阶函数" class="headerlink" title="1 高阶函数"></a>1 高阶函数</h3><ol>
<li><strong>定义：</strong>接受函数为参数，或者把函数作为结果返回的函数是高阶函数</li>
</ol>
<p>python3中的高阶函数:最为人熟知的高阶函数有<strong>map</strong>、<strong>filter</strong>、<strong>reduce</strong>.</p>
<p><strong>map</strong>和<strong>filter</strong>可以使用列表推导式或者使用生成器表达式代替，避免了匿名函数，<strong>reduce</strong>是用来求和的函数，使用<strong>sum</strong>代替了</p>
<p>all(iterable):如果iterable 的每个元素都是真值，返回True；all([]) 返回True.</p>
<p>any(iterable): 只要iterable 中有元素是真值，就返回True；any([]) 返回False。</p>
<h3 id="2-匿名函数"><a href="#2-匿名函数" class="headerlink" title="2.匿名函数"></a>2.匿名函数</h3><p>lambda 函数的定义体中不能赋值，也不能使用while和try 等Python 语句</p>
<h3 id="3-可调用对象"><a href="#3-可调用对象" class="headerlink" title="3.可调用对象"></a>3.可调用对象</h3><ul>
<li>用户定义的函数</li>
<li>内置函数</li>
<li>在类的定义体中定义的函数</li>
<li>调用类时会运行类的<code>__new__</code> 方法创建一个实例，然后运行<br><code>__init__</code> 方法，初始化实例，最后把实例返回给调用方</li>
<li>类的实例：类定义了<strong>call</strong> 方法，那么它的实例可以作为函数调用。</li>
<li>生成器函数。使用yield 关键字的函数或方法。调用生成器函数返回的是生成器对象。</li>
</ul>
<p>判断一个对象是否是可调用使用:Python 中有各种各样可调用的类型，因此判断对象能否调用，最安<br>全的方法是使用内置的<strong>callable()</strong> 函数</p>
<h3 id="4-用户自定义的可调用类型"><a href="#4-用户自定义的可调用类型" class="headerlink" title="4.用户自定义的可调用类型"></a>4.用户自定义的可调用类型</h3><p>实现类的<strong>call</strong>的特殊方法，就能将类实现函数式调用。</p>
<h3 id="5-函数内省"><a href="#5-函数内省" class="headerlink" title="5.函数内省"></a>5.函数内省</h3><p>把函数视作对象特有的特性。dir 函数可以探知函数具有下述属性：</p>
<p>函数对象的特殊方法：</p>
<ul>
<li><code>__dict__</code></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">starjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/07/15/liu-chang-de-python-xue-xi-bi-ji/">http://yoursite.com/2019/07/15/liu-chang-de-python-xue-xi-bi-ji/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/07/15/zhan-he-dui-lie-suan-fa-ti/"><i class="fa fa-chevron-left">  </i><span>栈和队列算法题</span></a></div><div class="next-post pull-right"><a href="/2019/07/14/billu-box-ba-ji-shen-tou/"><span>Billu_box靶机渗透</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By starjian</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>