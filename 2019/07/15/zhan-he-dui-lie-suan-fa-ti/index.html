<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="栈和队列算法题"><meta name="keywords" content><meta name="author" content="starjian"><meta name="copyright" content="starjian"><title>栈和队列算法题 | 星晴</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#栈和队列的算法"><span class="toc-number">1.</span> <span class="toc-text">栈和队列的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-设计一个栈，在实现栈的基本功能的基础上，再实现返回栈中的最小元素的操作"><span class="toc-number">1.1.</span> <span class="toc-text">1.设计一个栈，在实现栈的基本功能的基础上，再实现返回栈中的最小元素的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-用两个栈组成队列"><span class="toc-number">1.2.</span> <span class="toc-text">2.用两个栈组成队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-使用仅用递归函数和栈逆序一个栈"><span class="toc-number">1.3.</span> <span class="toc-text">3.使用仅用递归函数和栈逆序一个栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-用一个栈实现另一个栈的排序"><span class="toc-number">1.4.</span> <span class="toc-text">4.用一个栈实现另一个栈的排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-正常的汉贝塔问题"><span class="toc-number">1.5.</span> <span class="toc-text">5.正常的汉贝塔问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-用栈来求解有限制的汉贝塔问题"><span class="toc-number">1.6.</span> <span class="toc-text">6.用栈来求解有限制的汉贝塔问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-滑动窗口"><span class="toc-number">1.7.</span> <span class="toc-text">7.滑动窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-求最大子矩阵的大小"><span class="toc-number">1.8.</span> <span class="toc-text">8.求最大子矩阵的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-两数相加"><span class="toc-number">1.9.</span> <span class="toc-text">9.两数相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-爬楼梯问题"><span class="toc-number">1.10.</span> <span class="toc-text">10.爬楼梯问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-求众数"><span class="toc-number">1.11.</span> <span class="toc-text">11.求众数</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">starjian</div><div class="author-info__description text-center">白帽子星晴的成长记录博客</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">36</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">星晴</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">栈和队列算法题</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-15</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="栈和队列的算法"><a href="#栈和队列的算法" class="headerlink" title="栈和队列的算法"></a>栈和队列的算法</h1><hr>
<h2 id="1-设计一个栈，在实现栈的基本功能的基础上，再实现返回栈中的最小元素的操作"><a href="#1-设计一个栈，在实现栈的基本功能的基础上，再实现返回栈中的最小元素的操作" class="headerlink" title="1.设计一个栈，在实现栈的基本功能的基础上，再实现返回栈中的最小元素的操作"></a>1.设计一个栈，在实现栈的基本功能的基础上，再实现返回栈中的最小元素的操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">设计一个栈，在实现栈的基本功能的基础上，再实现返回栈中的最小元素的操作</span></span><br><span class="line"><span class="string">1. 要求pop、push、getMin操作的时间复杂度都是O(1)</span></span><br><span class="line"><span class="string">2. 设计的栈类型可以使用现成的栈结构</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">getMinStack</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.mydeque=deque()</span><br><span class="line">		self.mixdeque=deque()</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,element)</span>:</span></span><br><span class="line">		<span class="keyword">if</span>(len(self.mydeque)==<span class="number">0</span>):</span><br><span class="line">			self.mydeque.append(element)</span><br><span class="line">			self.mixdeque.append(element)</span><br><span class="line">		<span class="keyword">elif</span> <span class="keyword">not</span> element&gt;mixdeque[<span class="number">-1</span>]:</span><br><span class="line">			self.mixdeque.append(element)</span><br><span class="line">		self.mydeque.append(element)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">		element=self.mydeque.pop()</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> element&gt;self.mixdeque[<span class="number">-1</span>]:</span><br><span class="line">			self.mixdeque.pop()</span><br><span class="line">		<span class="keyword">return</span> element</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">getMix</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.mixdeque[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __main__==<span class="string">"__name__"</span>:</span><br><span class="line">	test=getMinStack()</span><br><span class="line">	a=range(<span class="number">1</span>,<span class="number">100</span>,<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> random.sample(a, <span class="number">9</span>):</span><br><span class="line">		test.push(i)</span><br></pre></td></tr></table></figure>
<h2 id="2-用两个栈组成队列"><a href="#2-用两个栈组成队列" class="headerlink" title="2.用两个栈组成队列"></a>2.用两个栈组成队列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoStackQueue</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    初始化两个空栈</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stackPush=deque()</span><br><span class="line">        self.stackPop=deque()</span><br><span class="line">    </span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    向栈中添加元素,直接将元素加到push栈里面</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,number)</span>:</span></span><br><span class="line">         self.stackPush.append(number)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    pop需要先将push的一次倒出装到pop里面，然后从pop栈里面pop出一个元素</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.stackPop)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.stackPop.pop()</span><br><span class="line">        <span class="keyword">elif</span> len(self.stackPush)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> len(self.stackPush)&gt;<span class="number">0</span>:</span><br><span class="line">                self.stackPush.add(self.stackPush.pop())</span><br><span class="line">            <span class="keyword">return</span> self.stackPop.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"empty queue"</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peak</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.stackPop)==<span class="number">0</span>&amp;&amp;len(self.stackPush)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"empty queue"</span>)</span><br><span class="line">        <span class="keyword">elif</span> len(self.stackPush)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> len(self.stackPush)==<span class="number">0</span>:</span><br><span class="line">                self.stackPush.append(self.stackPush.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stackPop[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="3-使用仅用递归函数和栈逆序一个栈"><a href="#3-使用仅用递归函数和栈逆序一个栈" class="headerlink" title="3.使用仅用递归函数和栈逆序一个栈"></a>3.使用仅用递归函数和栈逆序一个栈</h2><p>递归的基本思想，是把规模较大的一个问题，分解成规模较小的多个子问题去解决，而每一个子问题又可以继续拆分成多个更小的子问题。或者说，必须先解决子问题，再基于子问题来解决当前问题。既然我们要逆序一个栈，就要将栈的最底部拿出来，先这样考虑，极限的情况下，栈只有一个元素，那么直接就弹出这个元素，不需要逆序，如果是两个的元素，先取出一个如果栈不是空的，就继续取，将最低的元素取出返回，再压栈。那么第一个函数 是:</p>
<p><img src="/.com//1563348840255.png" alt="1563348840255"></p>
<p>这个时候的函数为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAndRemoveLast</span><span class="params">(mylist)</span>:</span></span><br><span class="line">    result=mylist.pop()</span><br><span class="line">    <span class="keyword">if</span> len(mylist)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        last=getAndRemoveLast(mylist)</span><br><span class="line">        mylist.push(result)</span><br><span class="line">        <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>
<p><img src="/.com//1563349656167.png" alt="1563349656167"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">revers</span><span class="params">(mylist)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(mylist)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    temp=getAndRemoveLast(mylist)</span><br><span class="line">    revers(mylist)</span><br><span class="line">    mylist.push(temp)</span><br></pre></td></tr></table></figure>
<h2 id="4-用一个栈实现另一个栈的排序"><a href="#4-用一个栈实现另一个栈的排序" class="headerlink" title="4.用一个栈实现另一个栈的排序"></a>4.用一个栈实现另一个栈的排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortBystack</span><span class="params">(mylist)</span>:</span></span><br><span class="line">    helpstack=deque()</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    只要栈不为空，就取出当前栈的最顶点的，然后和辅助栈的最上面进行比较，如果辅助栈比较大，就弹出来装到当前栈，这样的话，就会将辅助栈所有比当前栈顶大的全部放到当前栈</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">while</span> len(mylist)&gt;<span class="number">0</span>:</span><br><span class="line">        temp=mylist.pop()</span><br><span class="line">        <span class="keyword">while</span> len(helpstack)&gt;<span class="number">0</span>&amp;&amp;(helpstack[<span class="number">-1</span>]&gt;temp):</span><br><span class="line">            mylist.append(helpstack.pop())</span><br><span class="line">        helpstack.append(temp)</span><br><span class="line">    <span class="keyword">while</span> len(helpstack)&gt;<span class="number">0</span>:</span><br><span class="line">        mylist.append(helpstack.pop())</span><br></pre></td></tr></table></figure>
<h2 id="5-正常的汉贝塔问题"><a href="#5-正常的汉贝塔问题" class="headerlink" title="5.正常的汉贝塔问题"></a>5.正常的汉贝塔问题</h2><p>A，B，C三个圆柱，分别为初始位，过渡位，目标位，设A柱为初始位，C位为最终目标位。</p>
<p>（1）将最上面的n-1个圆盘从初始位移动到过渡位</p>
<p>（2）将初始位的最底下的一个圆盘移动到目标位</p>
<p>（3）将过渡位的n-1个圆盘移动到目标位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanbei</span><span class="params">(n,a,b,c)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        print(<span class="string">'&#123;0&#125;--&gt;&#123;1&#125;'</span>.format(a,c))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        hanbei(n<span class="number">-1</span>,a,c,b)</span><br><span class="line">        print(<span class="string">'&#123;0&#125;--&gt;&#123;1&#125;'</span>.format(a,c))</span><br><span class="line">        hanbei(n<span class="number">-1</span>,b,a,c)</span><br><span class="line"></span><br><span class="line">hanbei(<span class="number">3</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="6-用栈来求解有限制的汉贝塔问题"><a href="#6-用栈来求解有限制的汉贝塔问题" class="headerlink" title="6.用栈来求解有限制的汉贝塔问题"></a>6.用栈来求解有限制的汉贝塔问题</h2><p>不能从最右边的塔直接移动道最左侧，也不能从最左侧搬到最右侧，必须经过中间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanbita</span><span class="params">(num,left,mid,right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> num&lt;<span class="number">1</span>:</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        如果没用元素，直接就返回0</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        否则就返回一个递归函数</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">    <span class="keyword">return</span> process(num,left,mid,right,left,right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(num,left,mid,right,origh,to)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> num==<span class="number">1</span>:</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        如果数字只有一个，且出发点或者到达点是中间的那根柱子，那么直接移动过去，且移动了一次</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> origh==<span class="string">'mid'</span> <span class="keyword">or</span> to==<span class="string">'mid'</span>:</span><br><span class="line">            print(<span class="string">"move 1 from %s  to %s"</span>.format(origh,to))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        否则，那么就是从左到右，或者从右到左，那么必须经过中间那根柱子的移动，移动需要两次</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"move 1 from %s  to mid"</span>.format(origh))</span><br><span class="line">            print(<span class="string">"move 1 from %s  to %s"</span>.format(mid,to))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">from</span>==<span class="string">"mid"</span> <span class="keyword">or</span> origh==<span class="string">"mid"</span>:</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        如果是很多，不止一个，且是从中间搬到两边，或者两边搬到中间就先将上面的n-1先从左边搬到右边，采用递归的方式，</span></span><br><span class="line"><span class="string">        然后将最底下的搬到中间，最后再将n-1个搬到中间</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        another=(origh=="left")||(to=="left")?right:left</span><br><span class="line">        part1=process(num<span class="number">-1</span>,left,mid,right,origh,another)</span><br><span class="line">        part2=<span class="number">1</span></span><br><span class="line">        print(<span class="string">"move %s from %s to %s"</span>.format(num,origh,another))</span><br><span class="line">        part3=process(num<span class="number">-1</span>,left,mid,right,another,to)</span><br><span class="line">        <span class="keyword">return</span> part1+part2+part3</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        从左边移动到右边，或者从右边移动到左边</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        part1=process(num<span class="number">-1</span>,left,mid,right,origh,to)</span><br><span class="line">        part2=<span class="number">1</span></span><br><span class="line">        print(<span class="string">"move %s from %s to %s"</span>.format(num,origh,to))</span><br><span class="line">        part3=process(num<span class="number">-1</span>,left,mid,right,to,origh)</span><br><span class="line">        part4=<span class="number">1</span></span><br><span class="line">        print(<span class="string">"move %s from %s to %s"</span>.format(num,mid,to))</span><br><span class="line">        part5=process(num<span class="number">-1</span>,left,mid,right,origh,to)</span><br><span class="line">        <span class="keyword">return</span> part1+part2+part3+part4+part5</span><br></pre></td></tr></table></figure>
<h2 id="7-滑动窗口"><a href="#7-滑动窗口" class="headerlink" title="7.滑动窗口"></a>7.滑动窗口</h2><p>有一个整数数组arr和一个大小为w的窗口从数组的最左边滑到最右边，窗口每次都向右边滑一个位置，输入:整形数组arr，窗口大小为w</p>
<p>输出：一个长度为n-w+1的数组res,res[i]表示每一种窗口状态下的最大值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slide_windows</span><span class="params">(arr,w_size)</span>:</span></span><br><span class="line">    max_arr=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)-w_size+<span class="number">1</span>):</span><br><span class="line">        new_arr=arr[i:i+w_size]</span><br><span class="line">        max_arr.append(max(new_arr))</span><br><span class="line">    <span class="keyword">return</span> max_arr</span><br><span class="line">max_arr=slide_windows([<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>],<span class="number">3</span>)</span><br><span class="line">print(max_arr)</span><br></pre></td></tr></table></figure>
<h2 id="8-求最大子矩阵的大小"><a href="#8-求最大子矩阵的大小" class="headerlink" title="8.求最大子矩阵的大小"></a>8.求最大子矩阵的大小</h2><p>题目描述：给定一个整形的矩阵map，其中给的值只有0和1两种，求其中全是1的所有矩阵区域中，最大的矩形区域为1的数量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxRecSize</span><span class="params">(map)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxRecFromBottom</span><span class="params">(height)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> height == <span class="literal">None</span> <span class="keyword">or</span> len(height) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        stack = []</span><br><span class="line">        maxArea = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(height)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> height[stack[<span class="number">-1</span>]] &gt;= height[i]:</span><br><span class="line">                j = stack.pop()</span><br><span class="line">                k = stack[<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">                maxArea = max(maxArea, (i-k<span class="number">-1</span>) * height[j])</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            j = stack.pop()</span><br><span class="line">            k = stack[<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">            maxArea = max(maxArea, (len(height)-k<span class="number">-1</span>) * height[j])</span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> map == <span class="literal">None</span> <span class="keyword">or</span> len(map) == <span class="number">0</span> <span class="keyword">or</span> len(map[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    height = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(map[<span class="number">0</span>]))]</span><br><span class="line">    maxArea = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(map)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(map[<span class="number">0</span>])):</span><br><span class="line">            height[j] = <span class="number">0</span> <span class="keyword">if</span> map[i][j] == <span class="number">0</span> <span class="keyword">else</span> height[j] + <span class="number">1</span></span><br><span class="line">        maxArea = max(maxArea, maxRecFromBottom(height))</span><br><span class="line">    <span class="keyword">return</span> maxArea</span><br></pre></td></tr></table></figure>
<h2 id="9-两数相加"><a href="#9-两数相加" class="headerlink" title="9.两数相加"></a>9.两数相加</h2><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        tmp = ListNode(<span class="number">0</span>)</span><br><span class="line">        res = tmp</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            tmpsum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                tmpsum = l1.val</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                tmpsum += l2.val</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            tmpres = ((tmpsum + flag) % <span class="number">10</span>)</span><br><span class="line">            flag = ((tmpsum + flag) // <span class="number">10</span>)</span><br><span class="line">            res.next = ListNode(tmpres)</span><br><span class="line">            res = res.next</span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            res.next = ListNode(<span class="number">1</span>)</span><br><span class="line">        res = tmp.next</span><br><span class="line">        <span class="keyword">del</span> tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="10-爬楼梯问题"><a href="#10-爬楼梯问题" class="headerlink" title="10.爬楼梯问题"></a>10.爬楼梯问题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def fun(n):</span><br><span class="line">    if n==0:</span><br><span class="line">        return ‘error’</span><br><span class="line">    elif n==1:</span><br><span class="line">        return 1</span><br><span class="line">    elif n==2:</span><br><span class="line">        return 2</span><br><span class="line">    else:</span><br><span class="line">        return fun(n-2)+fun(n-1)</span><br><span class="line">print(fun(3))</span><br><span class="line"></span><br><span class="line"># 一次1和2和3个台阶</span><br><span class="line">#到n层有三种情况，n-3，n-2，n-1</span><br><span class="line">#分别的情况种类为fun1(n-3)，fun1(n-2)，fun1(n-1)</span><br><span class="line">def fun1(n):</span><br><span class="line">    if n==0:</span><br><span class="line">        return &apos;error&apos;</span><br><span class="line">    elif n == 1:</span><br><span class="line">        return 1</span><br><span class="line">    elif n==2:</span><br><span class="line">        return 2</span><br><span class="line">    elif n==3:</span><br><span class="line">        return 4</span><br><span class="line">    else:</span><br><span class="line">        return fun1(n-3)+fun1(n-2)+fun1(n-1)</span><br><span class="line">print(fun1(3))</span><br></pre></td></tr></table></figure>
<h2 id="11-求众数"><a href="#11-求众数" class="headerlink" title="11.求众数"></a>11.求众数</h2><p>给定一个大小为 <em>n</em> 的数组，找到其中的众数。众数是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。 </p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">starjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/07/15/zhan-he-dui-lie-suan-fa-ti/">http://yoursite.com/2019/07/15/zhan-he-dui-lie-suan-fa-ti/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/07/17/li-yong-pei-zhi-bu-dang-ti-quan/"><i class="fa fa-chevron-left">  </i><span>利用配置不当提权</span></a></div><div class="next-post pull-right"><a href="/2019/07/15/liu-chang-de-python-xue-xi-bi-ji/"><span>流畅的Python学习笔记</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By starjian</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>